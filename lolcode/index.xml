<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lolcodes on LOLCODE Documentation</title>
    <link>/lolcode/</link>
    <description>Recent content in Lolcodes on LOLCODE Documentation</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 05 May 2016 08:57:54 -0400</lastBuildDate>
    
	<atom:link href="/lolcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Calling</title>
      <link>/lolcode/calling/</link>
      <pubDate>Thu, 05 May 2016 08:57:54 -0400</pubDate>
      
      <guid>/lolcode/calling/</guid>
      <description>A function of given arity is called with:
I IZ &amp;lt;function name&amp;gt; [YR &amp;lt;expression1&amp;gt; [AN YR &amp;lt;expression2&amp;gt; [AN YR &amp;lt;expression3&amp;gt; ...]]] MKAY That is, an expression is formed by the function name followed by any arguments. Those arguments may themselves be expressions. The expressions&amp;rsquo; values are obtained before the function is called. The arity of the functions is determined in the definition.</description>
    </item>
    
    <item>
      <title>Definition</title>
      <link>/lolcode/definition/</link>
      <pubDate>Thu, 05 May 2016 08:57:54 -0400</pubDate>
      
      <guid>/lolcode/definition/</guid>
      <description>A function is demarked with the opening keyword HOW IZ I and the closing keyword IF U SAY SO. The syntax is as follows:
HOW IZ I &amp;lt;function name&amp;gt; [YR &amp;lt;argument1&amp;gt; [AN YR &amp;lt;argument2&amp;gt; â€¦]] &amp;lt;code block&amp;gt; IF U SAY SO Currently, the number of arguments in a function can only be defined as a fixed number. The &amp;lt;argument&amp;gt;s are single-word identifiers that act as variables within the scope of the function&amp;rsquo;s code.</description>
    </item>
    
    <item>
      <title>Returning</title>
      <link>/lolcode/returning/</link>
      <pubDate>Thu, 05 May 2016 08:57:54 -0400</pubDate>
      
      <guid>/lolcode/returning/</guid>
      <description>Return from the function is accomplished in one of the following ways:
 FOUND YR &amp;lt;expression&amp;gt; returns the value of the expression. GTFO returns with no value (NOOB). in the absence of any explicit break, when the end of the code block is reached (IF U SAY SO), the value in IT is returned.  Calling A function of given arity is called with:
I IZ &amp;lt;function name&amp;gt; [YR &amp;lt;expression1&amp;gt; [AN YR &amp;lt;expression2&amp;gt; [AN YR &amp;lt;expression3&amp;gt; .</description>
    </item>
    
    <item>
      <title>Conditionals</title>
      <link>/lolcode/conditionals/</link>
      <pubDate>Thu, 05 May 2016 08:55:44 -0400</pubDate>
      
      <guid>/lolcode/conditionals/</guid>
      <description>If-Then The traditional if/then construct is a very simple construct operating on the implicit IT variable. In the base form, there are four keywords: O RLY?, YA RLY, NO WAI, and OIC.
O RLY? branches to the block begun with YA RLY if IT can be cast to WIN, and branches to the NO WAI block if IT is FAIL. The code block introduced with YA RLY is implicitly closed when NO WAI is reached.</description>
    </item>
    
    <item>
      <title>Loops</title>
      <link>/lolcode/loops/</link>
      <pubDate>Thu, 05 May 2016 08:55:44 -0400</pubDate>
      
      <guid>/lolcode/loops/</guid>
      <description>Loops are currently defined more or less as they were in the original examples. Further looping constructs will be added to the language soon.
Simple loops are demarcated with IM IN YR &amp;lt;label&amp;gt; and IM OUTTA YR &amp;lt;label&amp;gt;. Loops defined this way are infinite loops that must be explicitly exited with a GTFO break. Currently, the &amp;lt;label&amp;gt; is required, but is unused, except for marking the start and end of the loop.</description>
    </item>
    
    <item>
      <title>Assignment Statements</title>
      <link>/lolcode/assign_statements/</link>
      <pubDate>Thu, 05 May 2016 08:50:24 -0400</pubDate>
      
      <guid>/lolcode/assign_statements/</guid>
      <description>Assignment statements have no side effects with IT. They are generally of the form:
&amp;lt;variable&amp;gt; &amp;lt;assignment operator&amp;gt; &amp;lt;expression&amp;gt; The variable being assigned may be used in the expression.</description>
    </item>
    
    <item>
      <title>Expression Statements</title>
      <link>/lolcode/expression_statements/</link>
      <pubDate>Thu, 05 May 2016 08:50:24 -0400</pubDate>
      
      <guid>/lolcode/expression_statements/</guid>
      <description>Expression Statements A bare expression (e.g. a function call or math operation), without any assignment, is a legal statement in LOLCODE. Aside from any side-effects from the expression when evaluated, the final value is placed in the temporary variable IT. IT&amp;rsquo;s value remains in local scope and exists until the next time it is replaced with a bare expression.</description>
    </item>
    
    <item>
      <title>Flow Control Statements</title>
      <link>/lolcode/flow_statements/</link>
      <pubDate>Thu, 05 May 2016 08:50:24 -0400</pubDate>
      
      <guid>/lolcode/flow_statements/</guid>
      <description>Flow control statements cover multiple lines and are described in the following section.</description>
    </item>
    
    <item>
      <title>Terminal-Based</title>
      <link>/lolcode/terminal_based/</link>
      <pubDate>Thu, 05 May 2016 08:48:38 -0400</pubDate>
      
      <guid>/lolcode/terminal_based/</guid>
      <description>The print (to STDOUT or the terminal) operator is VISIBLE. It has infinite arity and implicitly concatenates all of its arguments after casting them to YARNs. It is terminated by the statement delimiter (line end or comma). The output is automatically terminated with a carriage return (:)), unless the final token is terminated with an exclamation point (!), in which case the carriage return is suppressed.
VISIBLE &amp;lt;expression&amp;gt; [&amp;lt;expression&amp;gt; ...][!] There is currently no defined standard for printing to a file.</description>
    </item>
    
    <item>
      <title>Boolean</title>
      <link>/lolcode/boolean/</link>
      <pubDate>Thu, 05 May 2016 08:46:10 -0400</pubDate>
      
      <guid>/lolcode/boolean/</guid>
      <description>Boolean operators working on TROOFs are as follows:
BOTH OF &amp;lt;x&amp;gt; [AN] &amp;lt;y&amp;gt; BTW and: WIN iff x=WIN, y=WIN EITHER OF &amp;lt;x&amp;gt; [AN] &amp;lt;y&amp;gt; BTW or: FAIL iff x=FAIL, y=FAIL WON OF &amp;lt;x&amp;gt; [AN] &amp;lt;y&amp;gt; BTW xor: FAIL if x=y NOT &amp;lt;x&amp;gt; BTW unary negation: WIN if x=FAIL ALL OF &amp;lt;x&amp;gt; [AN] &amp;lt;y&amp;gt; ... MKAY BTW infinite arity AND ANY OF &amp;lt;x&amp;gt; [AN] &amp;lt;y&amp;gt; ... MKAY BTW infinite arity OR &amp;lt;x&amp;gt; and &amp;lt;y&amp;gt; in the expression syntaxes above are automatically cast as TROOF values if they are not already so.</description>
    </item>
    
    <item>
      <title>Calling Syntax and Precedence</title>
      <link>/lolcode/precedence/</link>
      <pubDate>Thu, 05 May 2016 08:46:10 -0400</pubDate>
      
      <guid>/lolcode/precedence/</guid>
      <description>Mathematical operators and functions in general rely on prefix notation. By doing this, it is possible to call and compose operations with a minimum of explicit grouping. When all operators and functions have known arity, no grouping markers are necessary. In cases where operators have variable arity, the operation is closed with MKAY. An MKAY may be omitted if it coincides with the end of the line/statement, in which case the EOL stands in for as many MKAYs as there are open variadic functions.</description>
    </item>
    
    <item>
      <title>Casting</title>
      <link>/lolcode/casting/</link>
      <pubDate>Thu, 05 May 2016 08:46:10 -0400</pubDate>
      
      <guid>/lolcode/casting/</guid>
      <description>Operators that work on specific types implicitly cast parameter values of other types. If the value cannot be safely cast, then it results in an error.
An expression&amp;rsquo;s value may be explicitly cast with the binary MAEK operator.
MAEK &amp;lt;expression&amp;gt; [A] &amp;lt;type&amp;gt; Where &amp;lt;type&amp;gt; is one of TROOF, YARN, NUMBR, NUMBAR, or NOOB. This is only for local casting: only the resultant value is cast, not the underlying variable(s), if any.</description>
    </item>
    
    <item>
      <title>Comparison</title>
      <link>/lolcode/comparison/</link>
      <pubDate>Thu, 05 May 2016 08:46:10 -0400</pubDate>
      
      <guid>/lolcode/comparison/</guid>
      <description>Comparison is (currently) done with two binary equality operators:
BOTH SAEM &amp;lt;x&amp;gt; [AN] &amp;lt;y&amp;gt; BTW WIN iff x == y DIFFRINT &amp;lt;x&amp;gt; [AN] &amp;lt;y&amp;gt; BTW WIN iff x != y Comparisons are performed as integer math in the presence of two NUMBRs, but if either of the expressions are NUMBARs, then floating point math takes over. Otherwise, there is no automatic casting in the equality, so BOTH SAEM &amp;quot;3&amp;quot; AN 3 is FAIL.</description>
    </item>
    
    <item>
      <title>Concatenation</title>
      <link>/lolcode/concatenation/</link>
      <pubDate>Thu, 05 May 2016 08:46:10 -0400</pubDate>
      
      <guid>/lolcode/concatenation/</guid>
      <description>An indefinite number of YARNs may be explicitly concatenated with the SMOOSH...MKAY operator. Arguments may optionally be separated with AN. As the SMOOSH expects strings as its input arguments, it will implicitly cast all input values of other types to YARNs. The line ending may safely implicitly close the SMOOSH operator without needing an MKAY.</description>
    </item>
    
    <item>
      <title>Math</title>
      <link>/lolcode/math/</link>
      <pubDate>Thu, 05 May 2016 08:46:10 -0400</pubDate>
      
      <guid>/lolcode/math/</guid>
      <description>Math The basic math operators are binary prefix operators.
SUM OF &amp;lt;x&amp;gt; AN &amp;lt;y&amp;gt; BTW + DIFF OF &amp;lt;x&amp;gt; AN &amp;lt;y&amp;gt; BTW - PRODUKT OF &amp;lt;x&amp;gt; AN &amp;lt;y&amp;gt; BTW * QUOSHUNT OF &amp;lt;x&amp;gt; AN &amp;lt;y&amp;gt; BTW / MOD OF &amp;lt;x&amp;gt; AN &amp;lt;y&amp;gt; BTW modulo BIGGR OF &amp;lt;x&amp;gt; AN &amp;lt;y&amp;gt; BTW max SMALLR OF &amp;lt;x&amp;gt; AN &amp;lt;y&amp;gt; BTW min &amp;lt;x&amp;gt; and &amp;lt;y&amp;gt; may each be expressions in the above, so mathematical operators can be nested and grouped indefinitely.</description>
    </item>
    
    <item>
      <title></title>
      <link>/lolcode/about_types/</link>
      <pubDate>Thu, 05 May 2016 08:41:21 -0400</pubDate>
      
      <guid>/lolcode/about_types/</guid>
      <description>(updated from 1.1)
The variable types that LOLCODE currently recognizes are: strings (YARN), integers (NUMBR), floats (NUMBAR), and booleans (TROOF) (Arrays (BUKKIT) are reserved for future expansion.) Typing is handled dynamically. Until a variable is given an initial value, it is untyped (NOOB). Casting operations operate on TYPE types, as well.</description>
    </item>
    
    <item>
      <title>Arrays</title>
      <link>/lolcode/arrays/</link>
      <pubDate>Thu, 05 May 2016 08:41:21 -0400</pubDate>
      
      <guid>/lolcode/arrays/</guid>
      <description>Array and dictionary types are currently under-specified. There is general will to unify them, but indexing and definition is still under discussion.</description>
    </item>
    
    <item>
      <title>Booleans</title>
      <link>/lolcode/booleans/</link>
      <pubDate>Thu, 05 May 2016 08:41:21 -0400</pubDate>
      
      <guid>/lolcode/booleans/</guid>
      <description>The two boolean (TROOF) values are WIN (true) and FAIL (false). The empty string (&amp;ldquo;&amp;rdquo;), an empty array, and numerical zero are all cast to FAIL. All other values evaluate to WIN.</description>
    </item>
    
    <item>
      <title>Numerical Types</title>
      <link>/lolcode/numerical/</link>
      <pubDate>Thu, 05 May 2016 08:41:21 -0400</pubDate>
      
      <guid>/lolcode/numerical/</guid>
      <description>A NUMBR is an integer as specified in the host implementation/architecture. Any contiguous sequence of digits outside of a quoted YARN and not containing a decimal point (.) is considered a NUMBR. A NUMBR may have a leading hyphen (-) to signify a negative number.
A NUMBAR is a float as specified in the host implementation/architecture. It is represented as a contiguous string of digits containing exactly one decimal point. Casting a NUMBAR to a NUMBR truncates the decimal portion of the floating point number.</description>
    </item>
    
    <item>
      <title>Strings</title>
      <link>/lolcode/strings/</link>
      <pubDate>Thu, 05 May 2016 08:41:21 -0400</pubDate>
      
      <guid>/lolcode/strings/</guid>
      <description>String literals (YARN) are demarked with double quotation marks (&amp;ldquo;). Line continuation and soft-command-breaks are ignored inside quoted strings. An unterminated string literal (no closing quote) will cause an error.
Within a string, all characters represent their literal value except the colon (:), which is the escape character. Characters immediately following the colon also take on a special meaning.
 :) represents a newline (\n) :&amp;gt; represents a tab (\t) :o represents a bell (beep) (\g) :&amp;rdquo; represents a literal double quote (&amp;ldquo;) :: represents a single literal colon (:)  The colon may also introduce more verbose escapes enclosed within some form of bracket.</description>
    </item>
    
    <item>
      <title>Types</title>
      <link>/lolcode/types/</link>
      <pubDate>Thu, 05 May 2016 08:41:21 -0400</pubDate>
      
      <guid>/lolcode/types/</guid>
      <description>The TYPE type only has the values of TROOF, NOOB, NUMBR, NUMBAR, YARN, and TYPE, as bare words. They may be legally cast to TROOF (all true except for NOOB) or YARN.
TYPEs are under current review. Current sentiment is to delay defining them until user-defined types are relevant, but that would mean that type comparisons are left unresolved in the meantime.</description>
    </item>
    
    <item>
      <title>Untyped</title>
      <link>/lolcode/untyped/</link>
      <pubDate>Thu, 05 May 2016 08:41:21 -0400</pubDate>
      
      <guid>/lolcode/untyped/</guid>
      <description>The untyped type (NOOB) cannot be implicitly cast into any type except a TROOF. A cast into TROOF makes the variable FAIL. Any operations on a NOOB that assume another type (e.g., math) results in an error.
Explicit casts of a NOOB (untyped, uninitialized) variable are to empty/zero values for all other types.</description>
    </item>
    
    <item>
      <title>Declaration and Assignment</title>
      <link>/lolcode/declaration/</link>
      <pubDate>Thu, 05 May 2016 08:39:55 -0400</pubDate>
      
      <guid>/lolcode/declaration/</guid>
      <description>(modified from 1.1)
To declare a variable, the keyword is I HAS A followed by the variable name. To assign the variable a value within the same statement, you can then follow the variable name with ITZ &amp;lt;value&amp;gt;.
Assignment of a variable is accomplished with an assignment statement, &amp;lt;variable&amp;gt; R &amp;lt;expression&amp;gt;
I HAS A VAR BTW VAR is null and untyped VAR R &amp;#34;THREE&amp;#34; BTW VAR is now a YARN and equals &amp;#34;THREE&amp;#34; VAR R 3 BTW VAR is now a NUMBR and equals 3</description>
    </item>
    
    <item>
      <title>Naming</title>
      <link>/lolcode/naming/</link>
      <pubDate>Thu, 05 May 2016 08:39:55 -0400</pubDate>
      
      <guid>/lolcode/naming/</guid>
      <description>(from 1.1)
Variable identifiers may be in all small or lowercase letters (or a mixture of the two). They must begin with a letter and may be followed only by other letters, numbers, and underscores. No spaces, dashes, or other symbols are allowed. Variable identifiers are CASE SENSITIVE â€“ &amp;ldquo;cheezburger&amp;rdquo;, &amp;ldquo;CheezBurger&amp;rdquo; and &amp;ldquo;CHEEZBURGER&amp;rdquo; would all be different variables.</description>
    </item>
    
    <item>
      <title>Scope</title>
      <link>/lolcode/scope/</link>
      <pubDate>Thu, 05 May 2016 08:39:55 -0400</pubDate>
      
      <guid>/lolcode/scope/</guid>
      <description>(to be revisited and refined)
All variable scope, as of this version, is local to the enclosing function or to the main program block. Variables are only accessible after declaration, and there is no global scope.</description>
    </item>
    
    <item>
      <title>Comments</title>
      <link>/lolcode/comments/</link>
      <pubDate>Wed, 04 May 2016 17:35:01 -0400</pubDate>
      
      <guid>/lolcode/comments/</guid>
      <description>(from 1.1)
Single line comments are begun by BTW, and may occur either after a line of code, on a separate line, or following a line of code following a line separator (,).
All of these are valid single line comments:
I HAS A VAR ITZ 12 BTW VAR = 12I HAS A VAR ITZ 12, BTW VAR = 12I HAS A VAR ITZ 12 BTW VAR = 12 Multi-line comments are begun by OBTW and ended with TLDR, and should be started on their own lines, or following a line of code after a line separator.</description>
    </item>
    
    <item>
      <title>File Creation</title>
      <link>/lolcode/file_creation/</link>
      <pubDate>Wed, 04 May 2016 17:35:01 -0400</pubDate>
      
      <guid>/lolcode/file_creation/</guid>
      <description>(modified from 1.1)
All LOLCODE programs must be opened with the command HAI. HAI should then be followed with the current LOLCODE language version number (1.2, in this case). There is no current standard behavior for implementations to treat the version number, though.
A LOLCODE file is closed by the keyword KTHXBYE which closes the HAI code-block.</description>
    </item>
    
    <item>
      <title>Whitespace</title>
      <link>/lolcode/whitespace/</link>
      <pubDate>Wed, 04 May 2016 17:35:01 -0400</pubDate>
      
      <guid>/lolcode/whitespace/</guid>
      <description>Spaces are used to demarcate tokens in the language, although some keyword constructs may include spaces.
 Multiple spaces and tabs are treated as single spaces and are otherwise irrelevant.
 Indentation is irrelevant.
 A command starts at the beginning of a line and a newline indicates the end of a command, except in special cases.
 A newline will be Carriage Return (/13), a Line Feed (/10) or both (/13/10) depending on the implementing system.</description>
    </item>
    
  </channel>
</rss>